'''This script will do every possible reconassiance with an ability to print the output in terminal and to store the output in a given file with 
'filename.txt' extention.
To get the results from shodan, you need an api key from shodan and replace the api key with given key in this program.'''

import whois
import dns.resolver
import argparse
import requests
import socket
import shodan
import sys

# Define the Tee class for redirecting output to multiple streams
class Tee:
    def __init__(self, *files):
        self.files = files

    def write(self, obj):
        for f in self.files:
            f.write(obj)

    def flush(self):
        for f in self.files:
            f.flush()

# Define a function to perform the reconnaissance tasks
def perform_recon(domain, ip=None):
    # python-whois & whois module
    print("[+] Getting whois info...")
    try:
        who = whois.query(domain)  # Query whois information for the specified domain
        # Print the retrieved whois information
        print(f"Name: {who.name}")
        print(f"Registrar: {who.registrar}")
        print(f"Name Servers: {who.name_servers}")
        print(f"Creation Date: {who.creation_date}")
        print(f"Expiration Date: {who.expiration_date}")
        print(f"Emails: {who.emails}")
    except Exception as e:
        print(f"There is an error in whois info: {e}")  # Handle any exceptions related to whois information retrieval

    # DNS module
    print("\n\n[+] Getting DNS info")
    record_types = ['A', 'NS', 'MX', 'TXT']
    for record_type in record_types:
        try:
            print(f"\n\n'{record_type}' Records are here")
            for rec in dns.resolver.resolve(domain, record_type):  # Resolve DNS records for the domain
                print(f"[+] {record_type} Record: {rec.to_text()}")  # Print the resolved DNS records
        except Exception as e:
            print(f"There is an error in DNS '{record_type}' Records: {e}")  # Handle any exceptions related to DNS record resolution

    # Geolocation module
    print("\n\n[+] Getting geolocation info")
    try:
        response = requests.get(f"https://geolocation-db.com/json/{socket.gethostbyname(domain)}").json()
        # Retrieve geolocation information using an API and print the results
        print(f"[+] Country: {response['country_name']}")
        print(f"[+] Latitude: {response['latitude']}")
        print(f"[+] Longitude: {response['longitude']}")
        print(f"[+] City: {response['city']}")
        print(f"[+] State: {response['state']}")
    except Exception as e:
        print(f"There is an error in fetching geolocation: {e}")  # Handle any exceptions related to geolocation information retrieval

    # Shodan module
    if ip:
        print("\n\n[+] Getting info from Shodan")
        api = shodan.Shodan("yEfgH1rg8p76Wgmivf9rpQ2iwFP0FiQ3")  # Initialize the Shodan API with the API key
        try:
            results = api.search(ip)  # Search Shodan for the specified IP
            print(f"[+] Results found: {results['total']}")  # Print the total results found
            for result in results['matches']:
                print(f"[+] IP: {result['ip_str']}")  # Print the IP addresses
                print(f"[+] Data: \n{result['data']}\n")  # Print the data associated with the IP
        except Exception as e:
            print(f"[-] Error in Shodan search: {e}")  # Handle any exceptions related to Shodan search

# Create an argument parser
arguments = argparse.ArgumentParser(description="This is a basic information gathering tool.", usage="python3 infogath.py -d DOMAIN [-s IP]")
arguments.add_argument("-d", "--domain", help="Enter the domain name for footprinting.")
arguments.add_argument("-s", "--shodan", help="Enter the IP for shodan search.")

args = arguments.parse_args()  # Parse the command-line arguments
domain = args.domain  # Get the domain name from the command-line arguments
ip = args.shodan  # Get the IP for Shodan search from the command-line arguments

# Prompt the user to decide whether to store the output or not
store_output = input("Do you want to store the output in a file? (yes/no): ")

if store_output.lower() == "yes":
    # If the user wants to store the output, prompt for the file name
    output_file = input("Enter the file name to store the output: ")

    try:
        # Open the file in append mode so that existing content is not overwritten
        with open(output_file, 'a') as f:
            # Redirect standard output to the file while preserving the original stdout
            original_stdout = sys.stdout
            sys.stdout = Tee(original_stdout, f)

            perform_recon(domain, ip)  # Perform the reconnaissance tasks

            # Restore the original stdout
            sys.stdout = original_stdout

    except Exception as e:
        print(f"An error occurred while writing to the file: {e}")
        sys.exit(1)  # Exit the script if an error occurs while writing to the file
else:
    perform_recon(domain, ip)  # Perform the reconnaissance tasks
